#!/usr/bin/env python3
import json
import os
import shutil
import subprocess
import time
from collections import deque
from threading import Thread, Event

from flask import Flask, jsonify, send_from_directory, request, abort

import paho.mqtt.client as mqtt

ADMIN_TOKEN = os.environ.get("ADMIN_TOKEN", "")

APP_HOST = os.environ.get("APP_HOST", "0.0.0.0")
APP_PORT = int(os.environ.get("APP_PORT", "80"))

MQTT_HOST = os.environ.get("MQTT_HOST", "127.0.0.1")
MQTT_PORT = int(os.environ.get("MQTT_PORT", "1883"))
MQTT_TOPIC = os.environ.get("MQTT_TOPIC", "sleigh/gps/#")
MQTT_USERNAME = os.environ.get("MQTT_USERNAME", "")
MQTT_PASSWORD = os.environ.get("MQTT_PASSWORD", "")

# Service names to check via systemd (adjust to your actual units)
GPSD_UNIT = os.environ.get("GPSD_UNIT", "gpsd.service")
MQTT_BROKER_UNIT = os.environ.get("MQTT_BROKER_UNIT", "mosquitto.service")
PUBLISHER_UNIT = os.environ.get("PUBLISHER_UNIT", "santa-publisher.service")

MAX_MESSAGES = int(os.environ.get("MAX_MESSAGES", "5"))
messages = deque(maxlen=MAX_MESSAGES)

app = Flask(__name__, static_folder="static")

@app.route("/api/service/<path:unit>/<action>", methods=["POST"])
def api_service_action(unit, action):
    if not is_authorized():
        abort(403)

    # SAFETY: only allow controlling the services we expose in /api/status
    allowed_units = {GPSD_UNIT, MQTT_BROKER_UNIT, PUBLISHER_UNIT}
    if unit not in allowed_units:
        return jsonify({
            "ok": False,
            "unit": unit,
            "action": action,
            "rc": 403,
            "stdout": "",
            "stderr": "Unit not permitted by this UI"
        }), 403

    rc, out, err = systemctl_action(unit, action)
    ok = (rc == 0)
    return jsonify({
        "ok": ok,
        "unit": unit,
        "action": action,
        "rc": rc,
        "stdout": out,
        "stderr": err,
    }), (200 if ok else 500)


stop_evt = Event()

def is_authorized():
    """
    If ADMIN_TOKEN is set, require it.
    If not set, only allow from localhost for safety.
    """
    if ADMIN_TOKEN:
        tok = request.headers.get("X-Auth-Token", "")
        return tok == ADMIN_TOKEN
    return request.remote_addr in ("127.0.0.1", "::1")


def systemctl_action(unit, action):
    if action not in ("start", "stop", "restart"):
        return 400, "", f"Invalid action: {action}"
    return run(["systemctl", action, unit], timeout=10)


def is_authorized():
    """
    If ADMIN_TOKEN is set, require it.
    If not set, only allow from localhost for safety.
    """
    if ADMIN_TOKEN:
        tok = request.headers.get("X-Auth-Token", "")
        return tok == ADMIN_TOKEN
    return request.remote_addr in ("127.0.0.1", "::1")


def systemctl_action(unit, action):
    if action not in ("start", "stop", "restart"):
        return 400, "", f"Invalid action: {action}"
    return run(["systemctl", action, unit], timeout=10)


def run(cmd, timeout=2):
    try:
        p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=timeout, text=True)
        return p.returncode, p.stdout.strip(), p.stderr.strip()
    except Exception as e:
        return 999, "", str(e)


def systemd_is_active(unit):
    rc, out, err = run(["systemctl", "is-active", unit])
    if rc == 0:
        return True, out
    return False, out or err


def systemd_status_line(unit):
    rc, out, err = run(["systemctl", "status", unit, "--no-pager", "-n", "2"])
    text = out or err
    # keep it compact
    lines = [ln for ln in text.splitlines() if ln.strip()]
    return lines[-1] if lines else ""


def get_gps_fix():
    """
    Try to get a single gps fix summary.
    Prefer python3-gps if present; fallback to gpspipe JSON.
    """
    # Try gpspipe first (very reliable as a quick probe)
    if shutil.which("gpspipe"):
        rc, out, err = run(["gpspipe", "-w", "-n", "10"], timeout=2)
        if rc == 0 and out:
            # Find a TPV sentence with lat/lon
            for line in out.splitlines():
                try:
                    obj = json.loads(line)
                except Exception:
                    continue
                if obj.get("class") == "TPV":
                    return {
                        "mode": obj.get("mode"),
                        "lat": obj.get("lat"),
                        "lon": obj.get("lon"),
                        "alt": obj.get("alt"),
                        "speed_mps": obj.get("speed"),
                        "time": obj.get("time"),
                    }
        # if gpspipe exists but gives nothing useful, fall through

    # Try python gps module
    try:
        from gps import gps, WATCH_ENABLE  # type: ignore

        s = gps(mode=WATCH_ENABLE)
        deadline = time.time() + 2.0
        last_tpv = None
        while time.time() < deadline:
            rep = s.next()
            if rep.get("class") == "TPV":
                last_tpv = rep
                if "lat" in rep and "lon" in rep:
                    break
        if last_tpv:
            return {
                "mode": last_tpv.get("mode"),
                "lat": last_tpv.get("lat"),
                "lon": last_tpv.get("lon"),
                "alt": last_tpv.get("alt"),
                "speed_mps": last_tpv.get("speed"),
                "time": last_tpv.get("time"),
            }
    except Exception:
        pass

    return None


def mqtt_on_connect(client, userdata, flags, rc):
    # Subscribe to your chosen topic tree
    client.subscribe(MQTT_TOPIC)


def mqtt_on_message(client, userdata, msg):
    try:
        payload = msg.payload.decode("utf-8", errors="replace")
    except Exception:
        payload = repr(msg.payload)
    messages.appendleft({
        "ts": time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
        "topic": msg.topic,
        "payload": payload[:500],  # prevent huge dumps
        "qos": msg.qos,
        "retain": msg.retain,
    })


def mqtt_thread():
    client = mqtt.Client()
    if MQTT_USERNAME:
        client.username_pw_set(MQTT_USERNAME, MQTT_PASSWORD)
    client.on_connect = mqtt_on_connect
    client.on_message = mqtt_on_message

    # Keep trying forever (simple + robust)
    while not stop_evt.is_set():
        try:
            client.connect(MQTT_HOST, MQTT_PORT, keepalive=30)
            client.loop_start()
            while not stop_evt.is_set():
                time.sleep(0.2)
            client.loop_stop()
            client.disconnect()
        except Exception:
            time.sleep(1.0)


@app.route("/")
def index():
    return send_from_directory("static", "index.html")


@app.route("/api/status")
def api_status():
    gpsd_ok, gpsd_state = systemd_is_active(GPSD_UNIT)
    broker_ok, broker_state = systemd_is_active(MQTT_BROKER_UNIT)
    pub_ok, pub_state = systemd_is_active(PUBLISHER_UNIT)

    fix = None
    if gpsd_ok:
        fix = get_gps_fix()

    return jsonify({
        "services": {
            "gpsd": {"unit": GPSD_UNIT, "active": gpsd_ok, "state": gpsd_state, "tail": systemd_status_line(GPSD_UNIT)},
            "mqtt_broker": {"unit": MQTT_BROKER_UNIT, "active": broker_ok, "state": broker_state, "tail": systemd_status_line(MQTT_BROKER_UNIT)},
            "publisher": {"unit": PUBLISHER_UNIT, "active": pub_ok, "state": pub_state, "tail": systemd_status_line(PUBLISHER_UNIT)},
        },
        "gps_fix": fix,
        "mqtt": {
            "subscribed_topic": MQTT_TOPIC,
            "last_messages": list(messages),
        },
        "server_time": time.strftime("%Y-%m-%d %H:%M:%S %Z", time.localtime())
    })


if __name__ == "__main__":
    # start mqtt subscriber
    Thread(target=mqtt_thread, daemon=True).start()
    app.run(host=APP_HOST, port=APP_PORT)
