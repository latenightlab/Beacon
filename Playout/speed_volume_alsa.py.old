import time
import subprocess
import json
import paho.mqtt.client as mqtt

MQTT_HOST = "192.168.1.211"   # <-- broker IP
TOPIC = "sleigh/gps/speed_kph"

# ALSA percentages
VOL_STOP = "50%"
VOL_MOVE = "100%"

# Mixer name: confirm with `amixer scontrols`
MIXER = "PCM"

# Thresholds in km/h
STOP_BELOW = 1.0
MOVE_ABOVE = 3.0

# Debounce times (seconds)
STOP_FOR = 2.5
MOVE_FOR = 2.0

last_speed = None
state = "UNKNOWN"
below_since = None
above_since = None

# Debugging
print(f"[STATE] -> STOPPED, setting {VOL_STOP}")
print(f"[STATE] -> MOVING, setting {VOL_MOVE}")

def set_volume(percent: str):
    subprocess.run(
        ["amixer", "sset", MIXER, percent],
        check=False,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )


def extract_speed_kph(payload: str):
    """
    Accepts:
      - plain number: "10"
      - JSON with speed_kph
      - JSON with speed_kmh
      - JSON with speed_mps (converted)
    Returns:
      float km/h or None
    """
    # 1) Try JSON
    try:
        data = json.loads(payload)

        if isinstance(data, dict):
            if "speed_kph" in data:
                return float(data["speed_kph"])
            if "speed_kmh" in data:
                return float(data["speed_kmh"])
            if "speed_mps" in data:
                return float(data["speed_mps"]) * 3.6

        return None
    except json.JSONDecodeError:
        pass

    # 2) Fallback: plain numeric string
    try:
        return float(payload)
    except Exception:
        return None


def on_message(client, userdata, msg):
    global last_speed
    payload = msg.payload.decode("utf-8").strip()

    speed = extract_speed_kph(payload)
    if speed is not None:
        last_speed = speed
# Debugging
    print(f"[MQTT] payload={payload}")
    print(f"[MQTT] speed_kph={last_speed}")


client = mqtt.Client(client_id="sleigh-audio-alsa")
client.on_message = on_message
client.connect(MQTT_HOST, 1883, 60)
client.subscribe(TOPIC)
client.loop_start()


while True:
    now = time.time()
    s = last_speed

    if s is None:
        time.sleep(0.2)
        continue

    # --- State detection with hysteresis ---
    if s < STOP_BELOW:
        below_since = below_since or now
        above_since = None
    elif s > MOVE_ABOVE:
        above_since = above_since or now
        below_since = None
    # Deadband: do nothing

    # --- State transitions ---
    if state != "STOPPED" and below_since and (now - below_since) >= STOP_FOR:
        set_volume(VOL_STOP)
        state = "STOPPED"

    elif state != "MOVING" and above_since and (now - above_since) >= MOVE_FOR:
        set_volume(VOL_MOVE)
        state = "MOVING"

    time.sleep(0.25)
