#!/usr/bin/env python3
import os
import subprocess
import time
import logging
from collections import deque
from threading import Thread, Event

from flask import Flask, jsonify, send_from_directory, request, abort
import paho.mqtt.client as mqtt

ADMIN_TOKEN = os.environ.get("ADMIN_TOKEN", "")

APP_HOST = os.environ.get("APP_HOST", "0.0.0.0")
APP_PORT = int(os.environ.get("APP_PORT", "80"))

MQTT_HOST = os.environ.get("MQTT_HOST", "192.168.8.10")
MQTT_PORT = int(os.environ.get("MQTT_PORT", "1883"))
MQTT_TOPIC = os.environ.get("MQTT_TOPIC", "sleigh/gps/#")
# MQTT_USERNAME = os.environ.get("MQTT_USERNAME", "")
# MQTT_PASSWORD = os.environ.get("MQTT_PASSWORD", "")

# Services we want to report on (override with env if your unit names differ)
UNITS = [
    os.environ.get("MOPIDY_UNIT", "mopidy.service"),
    os.environ.get("SUPERVISOR_UNIT", "audio-supervisor.service"),
    os.environ.get("RASPOTIFY_UNIT", "raspotify.service"),
    os.environ.get("SPEEDVOL_UNIT", "speed-volume.service"),
]

MAX_MESSAGES = int(os.environ.get("MAX_MESSAGES", "5"))
messages = deque(maxlen=MAX_MESSAGES)

app = Flask(__name__, static_folder="static")
stop_evt = Event()

logging.basicConfig(level=logging.WARNING, format="%(asctime)s %(levelname)s %(message)s")
logging.getLogger("werkzeug").setLevel(logging.WARNING)
app.logger.setLevel(logging.WARNING)

mqtt_connected = False
mqtt_last_error = ""
mqtt_last_connect = ""
mqtt_last_subscribe = ""


def run(cmd, timeout=2):
    try:
        p = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            timeout=timeout,
            text=True
        )
        return p.returncode, p.stdout.strip(), p.stderr.strip()
    except Exception as e:
        return 999, "", str(e)


def is_authorized():
    """
    If ADMIN_TOKEN is set, require it.
    If not set, only allow from localhost for safety.
    """
    if ADMIN_TOKEN:
        tok = request.headers.get("X-Auth-Token", "")
        return tok == ADMIN_TOKEN
    return request.remote_addr in ("127.0.0.1", "::1")


def systemctl_action(unit, action):
    if action not in ("start", "stop", "restart"):
        return 400, "", f"Invalid action: {action}"
    return run(["systemctl", action, unit], timeout=10)


@app.route("/api/service/<path:unit>/<action>", methods=["POST"])
def api_service_action(unit, action):
    if not is_authorized():
        abort(403)

    # SAFETY: only allow controlling units we expose in /api/status
    allowed_units = set(UNITS)
    if unit not in allowed_units:
        return jsonify({
            "ok": False,
            "unit": unit,
            "action": action,
            "rc": 403,
            "stdout": "",
            "stderr": "Unit not permitted by this UI"
        }), 403

    rc, out, err = systemctl_action(unit, action)
    ok = (rc == 0)
    return jsonify({
        "ok": ok,
        "unit": unit,
        "action": action,
        "rc": rc,
        "stdout": out,
        "stderr": err,
    }), (200 if ok else 500)


def systemd_is_active(unit):
    rc, out, err = run(["systemctl", "is-active", unit])
    if rc == 0:
        return True, out
    return False, out or err


def systemd_status_tail(unit):
    rc, out, err = run(["systemctl", "status", unit, "--no-pager", "-n", "5"])
    text = out or err
    lines = [ln for ln in text.splitlines() if ln.strip()]
    return "\n".join(lines[-2:]) if lines else ""


def mqtt_on_connect(client, userdata, flags, rc):
    global mqtt_connected, mqtt_last_connect, mqtt_last_subscribe
    mqtt_last_connect = f"rc={rc}"
    if rc == 0:
        mqtt_connected = True
        (result, mid) = client.subscribe(MQTT_TOPIC)
        mqtt_last_subscribe = f"subscribe result={result} mid={mid} topic={MQTT_TOPIC}"
    else:
        mqtt_connected = False


def mqtt_on_message(client, userdata, msg):
    logging.debug("MQTT msg topic=%s", msg.topic)

    try:
        payload = msg.payload.decode("utf-8", errors="replace")
    except Exception:
        payload = repr(msg.payload)

    messages.appendleft({
        "ts": time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
        "topic": msg.topic,
        "payload": payload[:500],
        "qos": msg.qos,
        "retain": msg.retain,
    })


def mqtt_thread():
    client = mqtt.Client(callback_api_version=mqtt.CallbackAPIVersion.VERSION1)

    # If you later want auth, uncomment these AND re-add MQTT_USERNAME/PASSWORD above.
    # if MQTT_USERNAME:
    #     client.username_pw_set(MQTT_USERNAME, MQTT_PASSWORD)

    client.on_connect = mqtt_on_connect
    client.on_message = mqtt_on_message

    while not stop_evt.is_set():
        try:
            client.connect(MQTT_HOST, MQTT_PORT, keepalive=30)
            client.loop_start()
            while not stop_evt.is_set():
                time.sleep(0.2)
            client.loop_stop()
            client.disconnect()
        except Exception as e:
            global mqtt_connected, mqtt_last_error
            mqtt_connected = False
            mqtt_last_error = str(e)
            time.sleep(1.0)


@app.route("/")
def index():
    return send_from_directory("static", "index.html")


@app.route("/api/status")
def api_status():
    services = {}
    for unit in UNITS:
        ok, state = systemd_is_active(unit)
        services[unit] = {
            "unit": unit,
            "active": ok,
            "state": state,
            "tail": systemd_status_tail(unit),
        }

    return jsonify({
        "services": services,
        "mqtt": {
            "connected": mqtt_connected,
            "last_error": mqtt_last_error,
            "last_connect": mqtt_last_connect,
            "last_subscribe": mqtt_last_subscribe,
            "subscribed_topic": MQTT_TOPIC,
            "last_messages": list(messages),
        },
        "server_time": time.strftime("%Y-%m-%d %H:%M:%S %Z", time.localtime())
    })


if __name__ == "__main__":
    Thread(target=mqtt_thread, daemon=True).start()
    app.run(host=APP_HOST, port=APP_PORT)
