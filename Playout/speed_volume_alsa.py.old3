#!/usr/bin/env python3
import time
import json
import ast
import logging
import subprocess
import threading
import re
import paho.mqtt.client as mqtt

MQTT_HOST = "192.168.1.211"
MQTT_PORT = 1883
TOPIC = "sleigh/gps/speed_kph"

# ALSA percentages
VOL_STOP = "75%"
VOL_MOVE = "100%"

# Mixer name
MIXER = "PCM"

# Thresholds in km/h
STOP_BELOW = 1.0
MOVE_ABOVE = 3.0
STOP_FOR = 2.5
MOVE_FOR = 2.0

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
log = logging.getLogger("speed-volume")

lock = threading.Lock()
speed_event = threading.Event()
last_speed = None
last_rx_ts = 0.0


def set_volume(percent: str):
    res = subprocess.run(["amixer", "sset", MIXER, percent], capture_output=True, text=True)
    if res.returncode != 0:
        log.warning("amixer failed rc=%s stderr=%s", res.returncode, res.stderr.strip())
    else:
        log.info("Volume set: %s -> %s", MIXER, percent)


def _speed_from_dict(d):
    if not isinstance(d, dict):
        return None
    if "speed_kph" in d:
        return float(d["speed_kph"])
    if "speed_kmh" in d:
        return float(d["speed_kmh"])
    if "speed_mps" in d:
        return float(d["speed_mps"]) * 3.6
    return None


_json_bool_fix = re.compile(r"\b(true|false|null)\b")

def extract_speed_kph(payload: str):
    """
    Accept:
      - plain number: "0"
      - JSON: {"fix_ok": true, "speed_kmh": 0}
      - python-literal dict: {'fix_ok': True, 'speed_kmh': 0}
    """
    # 1) Strict JSON first (handles true/false/null correctly)
    try:
        d = json.loads(payload)
        s = _speed_from_dict(d)
        if s is not None:
            return s
    except Exception:
        pass

    # 2) Python literal fallback:
    # convert JSON booleans/null to Python so literal_eval can handle it
    try:
        pyish = payload
        pyish = pyish.replace("true", "True").replace("false", "False").replace("null", "None")
        d = ast.literal_eval(pyish)
        s = _speed_from_dict(d)
        if s is not None:
            return s
    except Exception:
        pass

    # 3) Plain float fallback
    try:
        return float(payload)
    except Exception:
        return None


def on_connect(client, userdata, flags, rc, properties=None):
    if rc == 0:
        log.info("MQTT connected %s:%s", MQTT_HOST, MQTT_PORT)
        client.subscribe(TOPIC)
        log.info("Subscribed %s", TOPIC)
    else:
        log.warning("MQTT connect failed rc=%s", rc)


def on_message(client, userdata, msg):
    global last_speed, last_rx_ts
    payload = msg.payload.decode("utf-8", errors="replace").strip()

    s = extract_speed_kph(payload)
    if s is None:
        log.warning("Ignored payload (could not parse speed): %r", payload[:250])
        return

    with lock:
        last_speed = s
        last_rx_ts = time.time()

    speed_event.set()


def main():
    state = "UNKNOWN"
    below_since = None
    above_since = None

    client = mqtt.Client(client_id="sleigh-audio-alsa")
    client.on_connect = on_connect
    client.on_message = on_message
    client.reconnect_delay_set(min_delay=1, max_delay=10)

    log.info("Connecting to MQTT broker...")
    client.connect(MQTT_HOST, MQTT_PORT, 60)
    client.loop_start()

    while True:
        speed_event.wait(timeout=0.25)
        speed_event.clear()

        now = time.time()
        with lock:
            s = last_speed
            rx_age = (now - last_rx_ts) if last_rx_ts else None

        if s is None:
            continue

        # Hysteresis + debounce
        if s < STOP_BELOW:
            below_since = below_since or now
            above_since = None
        elif s > MOVE_ABOVE:
            above_since = above_since or now
            below_since = None

        if state != "STOPPED" and below_since and (now - below_since) >= STOP_FOR:
            log.info("State -> STOPPED (speed=%.2f km/h)", s)
            set_volume(VOL_STOP)
            state = "STOPPED"

        elif state != "MOVING" and above_since and (now - above_since) >= MOVE_FOR:
            log.info("State -> MOVING (speed=%.2f km/h)", s)
            set_volume(VOL_MOVE)
            state = "MOVING"


if __name__ == "__main__":
    main()
