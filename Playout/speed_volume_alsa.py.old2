#!/usr/bin/env python3
import time
import json
import logging
import subprocess
import threading
import paho.mqtt.client as mqtt
import ast

# --- MQTT ---
MQTT_HOST = "192.168.1.211"
MQTT_PORT = 1883
TOPIC = "sleigh/gps/speed_kph"

# --- ALSA ---
MIXER = "PCM"
VOL_STOP = "80%"
VOL_MOVE = "100%"

# --- Thresholds (km/h) + debounce ---
STOP_BELOW = 1.0
MOVE_ABOVE = 3.0
STOP_FOR = 2.5
MOVE_FOR = 2.0

# --- Logging (journald-friendly) ---
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s %(message)s"
)
log = logging.getLogger("speed-volume")

# Shared state between MQTT thread and main loop
lock = threading.Lock()
speed_event = threading.Event()
last_speed = None
last_rx_ts = 0.0


def set_volume(percent: str):
    """
    Set ALSA mixer volume. Logs failures instead of silently ignoring.
    """
    try:
        res = subprocess.run(
            ["amixer", "sset", MIXER, percent],
            capture_output=True,
            text=True
        )
        if res.returncode != 0:
            log.warning("amixer failed (%s): %s", res.returncode, res.stderr.strip())
        else:
            log.info("Volume set: %s -> %s", MIXER, percent)
    except Exception as e:
        log.warning("amixer exception: %s", e)


# def extract_speed_kph(payload: str):
#    """
#    Accepts:
#      - plain number: "10"
#      - JSON with speed_kph
#      - JSON with speed_kmh
#      - JSON with speed_mps (converted)
#    Returns float km/h or None.
#    """
#    # Try JSON
#    try:
#        data = json.loads(payload)
#        if isinstance(data, dict):
#            if "speed_kph" in data:
#                return float(data["speed_kph"])
#            if "speed_kmh" in data:
#                return float(data["speed_kmh"])
#            if "speed_mps" in data:
#                return float(data["speed_mps"]) * 3.6
#        return None
#    except json.JSONDecodeError:
#        pass
#
#    # Fallback: plain float
#    try:
#        return float(payload)
#    except Exception:
#        return None

def extract_speed_kph(payload: str):
    """
    Accepts:
      - plain number: "10"
      - strict JSON dict: {"speed_kmh": 10.0, ...}
      - python dict string: {'speed_kmh': 10.0, ...} / True/False
    Returns float km/h or None.
    """

    def from_mapping(d):
        if not isinstance(d, dict):
            return None
        if "speed_kph" in d:
            return float(d["speed_kph"])
        if "speed_kmh" in d:
            return float(d["speed_kmh"])
        if "speed_mps" in d:
            return float(d["speed_mps"]) * 3.6
        return None

    # 1) Strict JSON
    try:
        return from_mapping(json.loads(payload))
    except Exception:
        pass

    # 2) Python literal dict (handles single quotes + True/False)
    try:
        return from_mapping(ast.literal_eval(payload))
    except Exception:
        pass

    # 3) Plain float
    try:
        return float(payload)
    except Exception:
        return None



def on_connect(client, userdata, flags, rc, properties=None):
    if rc == 0:
        log.info("MQTT connected to %s:%s", MQTT_HOST, MQTT_PORT)
        client.subscribe(TOPIC)
        log.info("Subscribed to %s", TOPIC)
    else:
        log.warning("MQTT connect failed rc=%s", rc)


def on_message(client, userdata, msg):
    global last_speed, last_rx_ts
    payload = msg.payload.decode("utf-8", errors="replace").strip()
    s = extract_speed_kph(payload)

    if s is None:
        log.warning("Ignored payload (no speed parsed): %r", payload[:200])
        return

    with lock:
        last_speed = s
        last_rx_ts = time.time()

    # Signal the main loop that we received something
    speed_event.set()


def main():
    global last_speed

    # State machine
    state = "UNKNOWN"   # STOPPED / MOVING / UNKNOWN
    below_since = None
    above_since = None

    client = mqtt.Client(client_id="sleigh-audio-alsa")
    client.on_connect = on_connect
    client.on_message = on_message

    # Auto-reconnect behaviour
    client.reconnect_delay_set(min_delay=1, max_delay=10)

    log.info("Connecting MQTT...")
    client.connect(MQTT_HOST, MQTT_PORT, 60)
    client.loop_start()

    while True:
        # Wait until we get at least one message, then continue ticking
        speed_event.wait(timeout=0.25)

        now = time.time()
        with lock:
            s = last_speed
            rx_age = now - last_rx_ts if last_rx_ts else None

        # Clear the event so we can detect “new data arrived”
        speed_event.clear()

        if s is None:
            continue

        # Optional safety: if no updates for 30s, treat as stopped
        if rx_age is not None and rx_age > 30:
            if state != "STOPPED":
                log.warning("No MQTT updates for %.1fs -> forcing STOPPED", rx_age)
                set_volume(VOL_STOP)
                state = "STOPPED"
            continue

        # Hysteresis + debounce logic
        if s < STOP_BELOW:
            below_since = below_since or now
            above_since = None
        elif s > MOVE_ABOVE:
            above_since = above_since or now
            below_since = None
        # deadband: keep timers as-is

        if state != "STOPPED" and below_since and (now - below_since) >= STOP_FOR:
            log.info("State -> STOPPED (speed=%.2f km/h)", s)
            set_volume(VOL_STOP)
            state = "STOPPED"

        elif state != "MOVING" and above_since and (now - above_since) >= MOVE_FOR:
            log.info("State -> MOVING (speed=%.2f km/h)", s)
            set_volume(VOL_MOVE)
            state = "MOVING"


if __name__ == "__main__":
    main()
